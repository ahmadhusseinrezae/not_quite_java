package analysis.symboltable;

import analysis.Analysis;
import java.util.ArrayList;
import java.util.Map;
import notquitejava.ast.*;

/**
 * ClassScope class provide abstraction for the class scope.
 *     @see Scope 
 *     It contains contextual information for the class scope. 
 *     Only one class is implementing this class.
 *     
 * @see ClassScopeImpl
 */
public interface ClassScope extends Scope {

    /**
     * It checks whether the class scope contains a field with passed name.
     *
     * @param varName It is the name of variable we looking for
     * @return boolean It is the result of check
     */
    public boolean containsField(String varName);

    /**
     * It add a function declaration into class scope.
     *
     * @param funcName It is the name of function ot be added
     *
     * @param funcSign It is a unique function signiture generated by a helper 
     *     function which is inside Helper 
     *     
     * @see Helper,
     *
     * @param func It is the function declaration for the function to be added
     */
    public void addFunction(String funcName, String funcSign, NQJFunctionDecl func);

    /**
     * It check whether class. 
     *     or its extended classes from inheretance 
     *     tree contains a function signiture equal.
     *
     * @param functionName It is the name of function used to retrive list 
     *     of overloading functions defined inside class with same name.
     *
     * @param args It is list of arguments which will be used to regenerate 
     *     the unique function signiture to find the function declaration.
     * @return NQJFunctionDecl It will be either null or an instance of 
     *     Function declaration.
     */
    public NQJFunctionDecl getFunction(String functionName, NQJExprList args);

    /**
     * It checks the existance of a function.
     * It checks whether a function with a particular function name and
     *     signiture exist inside a class scope
     *
     * @param functionName It is the function name
     *
     * @param functionSignitures It is a list of unique function signitures 
     *     generated by Helper class. it will be list of all possible function 
     *     signiture including all classes from parameter inheratence tree
     * @see Helper
     *
     * @param analysis It is a instance of analysis class which is centeral part 
     *     of analyse process and has instance of name table.
     * @return NQJFunctionDecl It will be either null or an instance of 
     *     Function declaration.
     */
    public NQJFunctionDecl checkGetFunction(
            String functionName, ArrayList<String> functionSignitures, 
                Analysis analysis);

    /**
     * It get the list of functions for given function name.
     * It take function name and return list of overloading function for that name
     *
     * @param functionName it is the function name
     * @return Map String, NQJFunctionDecl It will be either null or map of overloaded 
     *     function for the functions This map will be from function signiture to function 
     *     declration.
     */
    public Map<String, NQJFunctionDecl> getFunction(String functionName);

    /**
     * It adds a extended class.
     * It add a extended class with its contextual information which is an instance 
     *     of ClassScope to current class
     *
     * @param name It is the name of extended class
     *
     * @param classContx It is instance of classScope which has all information 
     *      for extended class
     */
    public void addExtendedClass(String name, ClassScope classContx);

    /**
     * It returns the extended class.
     * It get the extended class name and return the classScope if it exist
     *
     * @param classNme It is the name of extended class
     * @return ClassScope It will be either null if current class does not extend the 
     *     param name or ClassScope of that param if current class extend it.
     */
    public ClassScope getExtendedClass(String classNme);

    /**
     * It gives list of extended classes.
     * It return map of extended classes if there is any
     *
     * @return Map String, ClassScope It is a map of extended classes which is from 
     *     extended class name as key to extended ClassScope instance as value.
     */
    public Map<String, ClassScope> getExtendedClasses();

    /**
     * It check cycle conflict.
     * It check the cycle inheretance conflict in current class. It will call
     *     checkExtendedClasses with a simple map which initial has the current class 
     *     as only ancesstor.
     *
     * @see checkExtendedClasses
     */
    public void checkCycleConflict();

    /**
     * It checks extended classes.
     * It get a map of ancesstors, then it will loop into its extended classes and 
     *     check each one of them whether it exist inside ancesstors map it took as 
     *     parameter earlier. If ancesstors contains that entry, it will register an 
     *     error which indicate a cycle dependany. and it will throw an exception because 
     *     otherwise this dependancy will cause Stackoverflow problem which will not 
     *     be clear why it happend. If ancesstors does not contains that entry, it will 
     *     add that entry into ancesstors and call checkExtendedClasses from that entry 
     *     with that ancesstor map. It will recurrsivly continue until it reaches the top 
     *     of inheratance tree.
     *
     * @param ancesstors It is a map of ClassScopes which are ancesstors to current class.
     */
    public void checkExtendedClasses(Map<String, ClassScope> ancesstors);

    /**
     * It returns class dclaration.
     * It return class declaration for current class scope.
     *
     * @return NQJClassDecl It is the class declaration for current class scope
     */
    public NQJClassDecl getClassDecl();

    /**
     * It returns class name.
     *
     * @return String It is the name of class scope
     */
    public String getClassName();
}
